library(vcfR)
library(adegenet)
library(ggplot2)
library(RColorBrewer)

################## I. PCAs ##################

# Read vcf file
file <- "~/SNPs_SMALL.vcf.gz"
gal.vcf <- read.vcfR(file)
gal.gl <- vcfR2genlight(gal.vcf)
gal.gl

# Plot a heatmap of variants and samples
dp <- extract.gt(gal.vcf, element = "DP", as.numeric = TRUE)
heatmap.bp(dp, rlabels = FALSE)

# read in pop map and filter for missing individuals
file <- "~/popmap.txt"
popmap <- read.table(file)
n <- length(gal.gl$gen) + 1
samples <- names(gal.vcf@gt[1, 2:n])
popdata <- popmap[popmap$V1 %in% samples, ]
pop(gal.gl) <- popdata[ , 2]

# Run PCA
gal.pca <- glPca(gal.gl, nf = 3)

# Variance explained by PCs
barplot(100*gal.pca$eig/sum(gal.pca$eig), col = heat.colors(50), main="PCA Eigenvalues")
title(ylab="Percent of variance\nexplained", line = 2)
title(xlab="Eigenvalues", line = 1)
(gal.pca$eig[1]/sum(gal.pca$eig))*100
(gal.pca$eig[2]/sum(gal.pca$eig))*100
(gal.pca$eig[1]+gal.pca$eig[2])/sum(gal.pca$eig)

# Plot PCA
# pdf("~/galPCA.pdf", width = 10, height = 8)
gal.pca.scores <- as.data.frame(gal.pca$scores)
gal.pca.scores$pop <- pop(gal.gl)
names(gal.pca.scores)[4] <- "Population"
set.seed(9)
p <- ggplot(gal.pca.scores, aes(x = PC1, y = PC2, colour = Population) )
p <- p + geom_point(size = 8)
p <- p + geom_hline(yintercept = 0, size = 1) 
p <- p + geom_vline(xintercept = 0, size = 1) 
p <- p + theme(panel.grid.major = element_blank(),
               panel.grid.minor = element_blank(),
               panel.border = element_rect(colour = "black", fill = NA, size = 3),
               panel.background = element_rect(fill = "white"),
               plot.background = element_rect(fill = "white"), #alpha("grey85", 0.4)
               legend.key = element_blank(),
               axis.title=element_text(size=40),
               axis.text = element_text(size = 30))
p <- p + xlab("PC1 (41.4%)") + ylab("PC2 (0.7%)")
cols1 <- brewer.pal(9, "Purples")[4:9]
pal1 <- colorRampPalette(cols1)
cols2 <- brewer.pal(9, "Greens")[5:9]
pal2 <- colorRampPalette(cols2)

col2rgb(pal2(19)[14])
purple <- rgb(3, 112, 46, max = 255, alpha = 125)
col2rgb(pal1(11)[8])
green <- rgb(95, 60, 153, max = 255, alpha = 125)

p <- p + scale_color_manual(values=c(rep(purple, 19), rep(green, 11)))
p
# dev.off()

# PCA by species and neutral vs adaptive loci

# 1) Caes neutral

# Read in file
caes.vcf <- read.vcfR("SNPs_caes_SMALL.vcf")
caes.vcf

# Convert to genlight object
caes.gl <- vcfR2genlight(caes.vcf)
caes.gl

# read in pop map and filter for missing individuals
popmap <- read.table("popmap.txt")
n <- length(caes.gl$gen) + 1
samples <- names(caes.vcf@gt[1, 2:n])
popdata.caes <- popmap[popmap$V1 %in% samples, ]
pop(caes.gl) <- popdata.caes[ , 2]
caes.gl

# Filter out adaptive loci
cand.loci <- readLines("candidates_caes_stdcovBF10.txt")
chr <- sapply(strsplit(caes.gl@loc.names, "_"), function(x) x[1])
pos <- sapply(strsplit(caes.gl@loc.names, "_"), function(x) x[2])
caes.gl@loc.names <- paste0("X", chr, "__", chr, "_", pos, "__", pos)
caes.gl <- caes.gl[ , !caes.gl@loc.names %in% cand.loci]

# Run PCA
caes.pca <- glPca(caes.gl, nf = 3)

# Variance explained by PCs
barplot(100*caes.pca$eig/sum(caes.pca$eig), col = heat.colors(50), main="PCA Eigenvalues")
title(ylab="Percent of variance\nexplained", line = 2)
title(xlab="Eigenvalues", line = 1)
caes.pca$eig[1]/sum(caes.pca$eig)*100
caes.pca$eig[2]/sum(caes.pca$eig)*100
(caes.pca$eig[1]+caes.pca$eig[2])/sum(caes.pca$eig)

# Change pop names
pop.names <- as.character(pop(caes.gl))
library(xlsx)
pop_names.df <- read.xlsx(file = "~/Sampling Sites.xlsx", sheetIndex = 2, rowIndex = 1:31, colIndex = 1:4)
for(i in 1:30){
  pop.names[pop.names == pop_names.df$Full_ID[i]] <- pop_names.df$Name[i]
}
pop.names

# Set up location colours and shapes
colours <- rainbow(30)
colours <- colours[pop_names.df$Name %in% unique(pop.names)]
shapes <- rep(c(15:18, 20), 6)
shapes <- shapes[pop_names.df$Name %in% unique(pop.names)]

# Plot PCA
caes.pca.scores <- as.data.frame(caes.pca$scores)
caes.pca.scores$pop <- pop.names
names(caes.pca.scores)[4] <- "Location"
caes.pca.scores$Location <- as.factor(caes.pca.scores$Location)
caes.pca.scores$Location <- factor(caes.pca.scores$Location, levels = unique(pop.names))
p <- ggplot(caes.pca.scores, aes(x = PC1, y = PC2, colour = Location))
p <- p + geom_point(size = 8, aes(shape = Location))
p <- p + geom_hline(yintercept = 0, size = 1) 
p <- p + geom_vline(xintercept = 0, size = 1)
p <- p + theme(panel.grid.major = element_blank(),
               panel.grid.minor = element_blank(),
               panel.border = element_rect(colour = "black", fill = NA, size = 3),
               panel.background = element_rect(fill = "white"),
               plot.background = element_rect(fill = alpha("white", 1)),
               legend.key = element_blank(),
               axis.title=element_text(size=28),
               axis.text = element_text(size = 30),
               legend.title = element_text(size=20),
               legend.text = element_text(size=18))
p <- p + xlab("PC1 (1.38%)") + ylab("PC2 (1.34%)") # neutral: pc1 1.38%, pc2: 1.34% - adaptive: pc1: 9.96%, pc2: 8.04%
p <- p + scale_color_manual(values = colours) + scale_shape_manual(values = shapes)
caesNeut <- p
caesNeut

# 2) Caes adaptive

# Read in file
caes.vcf <- read.vcfR("SNPs_caes_BIG.vcf")
caes.vcf

# Convert to genlight object
caes.gl <- vcfR2genlight(caes.vcf)
caes.gl

# read in pop map and filter for missing individuals
popmap <- read.table("popmap.txt")
n <- length(caes.gl$gen) + 1
samples <- names(caes.vcf@gt[1, 2:n])
popdata.caes <- popmap[popmap$V1 %in% samples, ]
pop(caes.gl) <- popdata.caes[ , 2]
caes.gl

# PCA for candidate loci (BayPass) only
cand.loci <- readLines("candidates_caes_stdcovBF10.txt")
chr <- sapply(strsplit(caes.gl@loc.names, "_"), function(x) x[1])
pos <- sapply(strsplit(caes.gl@loc.names, "_"), function(x) x[2])
caes.gl@loc.names <- paste0("X", chr, "__", chr, "_", pos, "__", pos)
caes.gl <- caes.gl[ , caes.gl@loc.names %in% cand.loci]
caes.gl
caes.pca <- glPca(caes.gl, nf = 3)

# Variance explained by PCs
barplot(100*caes.pca$eig/sum(caes.pca$eig), col = heat.colors(50), main="PCA Eigenvalues")
title(ylab="Percent of variance\nexplained", line = 2)
title(xlab="Eigenvalues", line = 1)
caes.pca$eig[1]/sum(caes.pca$eig)*100
caes.pca$eig[2]/sum(caes.pca$eig)*100
(caes.pca$eig[1]+caes.pca$eig[2])/sum(caes.pca$eig)

# Change pop names
pop.names <- as.character(pop(caes.gl))
library(xlsx)
pop_names.df <- read.xlsx(file = "~/Sampling Sites.xlsx", sheetIndex = 2, rowIndex = 1:31, colIndex = 1:4)
for(i in 1:30){
  pop.names[pop.names == pop_names.df$Full_ID[i]] <- pop_names.df$Name[i]
}
pop.names

# Set up location colours
colours <- rainbow(30)
colours <- colours[pop_names.df$Name %in% unique(pop.names)]
shapes <- rep(c(15:18, 20), 6)
shapes <- shapes[pop_names.df$Name %in% unique(pop.names)]

# Plot PCA
caes.pca.scores <- as.data.frame(caes.pca$scores)
caes.pca.scores$pop <- pop.names
names(caes.pca.scores)[4] <- "Location"
caes.pca.scores$Location <- as.factor(caes.pca.scores$Location)
caes.pca.scores$Location <- factor(caes.pca.scores$Location, levels = unique(pop.names))
p <- ggplot(caes.pca.scores, aes(x = PC1, y = PC2, colour = Location))
p <- p + geom_point(size = 8, aes(shape = Location))
p <- p + geom_hline(yintercept = 0, size = 1) 
p <- p + geom_vline(xintercept = 0, size = 1) 
p <- p + theme(panel.grid.major = element_blank(),
               panel.grid.minor = element_blank(),
               panel.border = element_rect(colour = "black", fill = NA, size = 3),
               panel.background = element_rect(fill = "white"),
               plot.background = element_rect(fill = alpha("white", 1)),
               legend.key = element_blank(),
               axis.title=element_text(size=28),
               axis.text = element_text(size = 30),
               legend.title = element_text(size=20),
               legend.text = element_text(size=18))
p <- p + xlab("PC1 (9.96%)") + ylab("PC2 (8.04%)") # neutral: pc1 1.38%, pc2: 1.34% - adaptive: pc1: 9.96%, pc2: 8.04%
p <- p + scale_color_manual(values = colours) + scale_shape_manual(values = shapes)
caesAdapt <- p
caesAdapt

# 3) Gem neutral

# Read in file
gem.vcf <- read.vcfR("SNPs_gem_SMALL.vcf")
gem.vcf

# Convert to genlight object
gem.gl <- vcfR2genlight(gem.vcf)
gem.gl

# read in pop map and filter for missing individuals
popmap <- read.table("popmap.txt")
n <- length(gem.gl$gen) + 1
samples <- names(gem.vcf@gt[1, 2:n])
popdata.gem <- popmap[popmap$V1 %in% samples, ]
pop(gem.gl) <- popdata.gem[ , 2]
gem.gl

# Filter out adaptive loci
cand.loci <- readLines("candidates_gem_stdcovBF10.txt")
chr <- sapply(strsplit(gem.gl@loc.names, "_"), function(x) x[1])
pos <- sapply(strsplit(gem.gl@loc.names, "_"), function(x) x[2])
gem.gl@loc.names <- paste0("X", chr, "__", chr, "_", pos, "__", pos)
gem.gl <- gem.gl[ , !gem.gl@loc.names %in% cand.loci]

# Run PCA
gem.pca <- glPca(gem.gl, nf = 3)

# Variance explained by PCs
barplot(100*gem.pca$eig/sum(gem.pca$eig), col = heat.colors(50), main="PCA Eigenvalues")
title(ylab="Percent of variance\nexplained", line = 2)
title(xlab="Eigenvalues", line = 1)
gem.pca$eig[1]/sum(gem.pca$eig)*100
gem.pca$eig[2]/sum(gem.pca$eig)*100
(gem.pca$eig[1]+gem.pca$eig[2])/sum(gem.pca$eig)

# Change pop names
pop.names <- as.character(pop(gem.gl))
library(xlsx)
pop_names.df <- read.xlsx(file = "~/Sampling Sites.xlsx", sheetIndex = 2, rowIndex = 1:31, colIndex = 1:4)
for(i in 1:30){
  pop.names[pop.names == pop_names.df$Full_ID[i]] <- pop_names.df$Name[i]
}
pop.names

# Set up location colours
colours <- rainbow(30)
colours <- colours[pop_names.df$Name %in% unique(pop.names)]
shapes <- rep(c(15:18, 20), 6)
shapes <- shapes[pop_names.df$Name %in% unique(pop.names)]

# Plot PCA
gem.pca.scores <- as.data.frame(gem.pca$scores)
gem.pca.scores$pop <- pop.names
names(gem.pca.scores)[4] <- "Location"
gem.pca.scores$Location <- as.factor(gem.pca.scores$Location)
gem.pca.scores$Location <- factor(gem.pca.scores$Location, levels = unique(pop.names))
p <- ggplot(gem.pca.scores, aes(x = PC1, y = PC2, colour = Location))
p <- p + geom_point(size = 8, aes(shape = Location))
p <- p + geom_hline(yintercept = 0, size = 1) 
p <- p + geom_vline(xintercept = 0, size = 1) 
p <- p + theme(panel.grid.major = element_blank(),
               panel.grid.minor = element_blank(),
               panel.border = element_rect(colour = "black", fill = NA, size = 3),
               panel.background = element_rect(fill = "white"),
               plot.background = element_rect(fill = alpha("white", 1)),
               legend.key = element_blank(),
               axis.title=element_text(size=28),
               axis.text = element_text(size = 30),
               legend.title = element_text(size=20),
               legend.text = element_text(size=18))
p <- p + xlab("PC1 (1.61%)") + ylab("PC2 (1.46%)") # neutral: pc1 1.61%, pc2: 1.46% - adaptive: pc1: 26.54%, pc2: 9.59%
p <- p + scale_color_manual(values = colours) + guides(color=guide_legend(ncol=1)) + scale_shape_manual(values = shapes)
gemNeut <- p
gemNeut

# 4) Gem adaptive

# Read in file
gem.vcf <- read.vcfR("SNPs_gem_BIG.vcf")
gem.vcf

# Convert to genlight object
gem.gl <- vcfR2genlight(gem.vcf)
gem.gl

# read in pop map and filter for missing individuals
popmap <- read.table("popmap.txt")
n <- length(gem.gl$gen) + 1
samples <- names(gem.vcf@gt[1, 2:n])
popdata.gem <- popmap[popmap$V1 %in% samples, ]
pop(gem.gl) <- popdata.gem[ , 2]
gem.gl

# PCA for candidate loci (BayPass) only
cand.loci <- readLines("candidates_gem_stdcovBF10.txt")
chr <- sapply(strsplit(gem.gl@loc.names, "_"), function(x) x[1])
pos <- sapply(strsplit(gem.gl@loc.names, "_"), function(x) x[2])
gem.gl@loc.names <- paste0("X", chr, "__", chr, "_", pos, "__", pos)
gem.gl <- gem.gl[ , gem.gl@loc.names %in% cand.loci]
gem.gl
gem.pca <- glPca(gem.gl, nf = 3)

# Variance explained by PCs
barplot(100*gem.pca$eig/sum(gem.pca$eig), col = heat.colors(50), main="PCA Eigenvalues")
title(ylab="Percent of variance\nexplained", line = 2)
title(xlab="Eigenvalues", line = 1)
gem.pca$eig[1]/sum(gem.pca$eig)*100
gem.pca$eig[2]/sum(gem.pca$eig)*100
(gem.pca$eig[1]+gem.pca$eig[2])/sum(gem.pca$eig)

# Change pop names
pop.names <- as.character(pop(gem.gl))
library(xlsx)
pop_names.df <- read.xlsx(file = "~/Sampling Sites.xlsx", sheetIndex = 2, rowIndex = 1:31, colIndex = 1:4)
for(i in 1:30){
  pop.names[pop.names == pop_names.df$Full_ID[i]] <- pop_names.df$Name[i]
}
pop.names

# Set up location colours
colours <- rainbow(30)
colours <- colours[pop_names.df$Name %in% unique(pop.names)]
shapes <- rep(c(15:18, 20), 6)
shapes <- shapes[pop_names.df$Name %in% unique(pop.names)]

# Plot PCA
gem.pca.scores <- as.data.frame(gem.pca$scores)
gem.pca.scores$pop <- pop.names
names(gem.pca.scores)[4] <- "Location"
gem.pca.scores$Location <- as.factor(gem.pca.scores$Location)
gem.pca.scores$Location <- factor(gem.pca.scores$Location, levels = unique(pop.names))
p <- ggplot(gem.pca.scores, aes(x = PC1, y = PC2, colour = Location))
p <- p + geom_point(size = 8, aes(shape = Location))
p <- p + geom_hline(yintercept = 0, size = 1) 
p <- p + geom_vline(xintercept = 0, size = 1) 
p <- p + theme(panel.grid.major = element_blank(),
               panel.grid.minor = element_blank(),
               panel.border = element_rect(colour = "black", fill = NA, size = 3),
               panel.background = element_rect(fill = "white"),
               plot.background = element_rect(fill = alpha("white", 1)),
               legend.key = element_blank(),
               axis.title=element_text(size=28),
               axis.text = element_text(size = 30),
               legend.title = element_text(size=20),
               legend.text = element_text(size=18))
p <- p + xlab("PC1 (26.54%)") + ylab("PC2 (9.59%)") # neutral: pc1 1.61%, pc2: 1.46% - adaptive: pc1: 26.54%, pc2: 9.59%
p <- p + scale_color_manual(values = colours) + guides(color=guide_legend(ncol=1)) + scale_shape_manual(values = shapes)
gemAdapt <- p
gemAdapt

# Combine plots

# handy preview file for ggsave() (from here: https://gist.github.com/tjmahr/1dd36d78ecb3cff10baf01817a56e895)
ggpreview <- function(...) {
  fname <- tempfile(fileext = ".png")
  ggsave(filename = fname, ...)
  system2("open", fname)
  invisible(NULL)
}

# Common legend
library(ggpubr)

shapes <- rep(c(15:18, 20), 6)
dummydf <- data.frame(Location = pop_names.df$Name, x = 1:30, y = 1:30)
dummydf$Location <- factor(dummydf$Location, levels = pop_names.df$Name)
dummygg <- ggplot(data = dummydf, aes(x = x, y = y, colour = Location))
dymmygg <- dummygg + 
  geom_point(size = 8, aes(shape = Location)) + 
  scale_color_manual(values = rainbow(30)) +
  scale_shape_manual(values = shapes) +
  theme_classic() +
  guides(color=guide_legend(ncol=1)) +
  theme(legend.title = element_text(size=20),
        legend.text = element_text(size=18), 
        legend.background = element_rect(fill = "white"))
dymmygg
leg <- get_legend(dymmygg)

pcaPLot <- ggarrange(caesNeut, gemNeut, caesAdapt, gemAdapt,
                     labels = c("A", "B", "C", "D"), ncol = 2, nrow = 2, align = "hv",
                     font.label = list(face = "plain", size = 40), vjust = 1.25, common.legend = TRUE, legend = "right", legend.grob = leg)
pcaPLot

ggpreview(scale = 1, width = 50, height = 42, units = "cm", limitsize = F)
ggsave("~/pcaPlot.pdf", plot = pcaPLot, device = "pdf", scale = 1, width = 50, height = 42, units = "cm", limitsize = F)
ggsave("~/pcaPlot.png", plot = pcaPLot, device = "png", scale = 1, width = 50, height = 42, units = "cm", limitsize = F)


################## II. Within species Fsts ##################
library(vcfR)
library(hierfstat)
library(dartR)

# 1) G. caespitosa
# Read in file
caes.vcf <- read.vcfR("~/SNPs_caes_SMALL.vcf")
caes.vcf

# Convert to genlight object
caes.gl <- vcfR2genlight(caes.vcf)
caes.gl

# read in pop map and filter for missing individuals
popmap <- read.table("~/popmap.txt")
n <- length(caes.gl$gen) + 1
samples <- names(caes.vcf@gt[1, 2:n])
popdata.caes <- popmap[popmap$V1 %in% samples, ]
pop(caes.gl) <- popdata.caes[ , 2]
caes.gl

# Filter out pops with less than 3 individuals
caes.gl <- caes.gl[caes.gl@pop != names(table(caes.gl@pop)[table(caes.gl@pop) < 3]), ]
caes.gl

# Convert to genind format
caes.gi <- gl2gi(caes.gl)

# Calculate Fsts
caesfsts <- pairwise.fst(caes.gi, res.type = "matrix")
#write.csv(caesfsts, "~/caes_pairwise_fsts.csv")
#caesfsts <- read.csv("caes_pairwise_fsts.csv", row.names = 1)

# Eliminate elements above diagonal (redundant)
ini <- 2
for(i in 1:nrow(caesfsts)){
  if(ini < ncol(caesfsts)+1){
    for(j in ini:ncol(caesfsts)){
      caesfsts[i, j] <- NA
    }
    ini <- ini + 1
  }
}
#

# Convert to long (tify) data table
library(tidyr)
tidycaesfsts <- as.data.frame(caesfsts)
tidycaesfsts <- cbind(pop1 = rownames(tidycaesfsts), tidycaesfsts)
tidycaesfsts <- gather(tidycaesfsts, "pop2", "fst", -pop1, na.rm = TRUE)
#

# Calculate mean fst with se
fsts <- tidycaesfsts$fst
fsts[fsts <= 0] <- NA
mean(fsts, na.rm = TRUE)
sd(fsts, na.rm = TRUE)/sqrt(length(fsts))
#

# Change pop names
pop.names <- tidycaesfsts[ , 1:2]
library(xlsx)
pop_names.df <- read.xlsx(file = "~/Sampling Sites.xlsx", sheetIndex = 2, rowIndex = 1:31, colIndex = 1:4)
for(j in 1:2){
  for(i in 1:30){
    pop.names[pop.names[ , j] == pop_names.df$Full_ID[i], j] <- pop_names.df$Name[i]
  }
}
tidycaesfsts[ , 1:2] <- pop.names
tidycaesfsts$pop1 <- as.factor(tidycaesfsts$pop1)
tidycaesfsts$pop1 <- factor(tidycaesfsts$pop1, levels = unique(pop.names$pop1))
tidycaesfsts$pop2 <- as.factor(tidycaesfsts$pop2)
tidycaesfsts$pop2 <- factor(tidycaesfsts$pop2, levels = unique(pop.names$pop2))

# Plot Fsts
pdf("~/Fst heatmap caes.pdf", width = 6.2, height = 4.98)
tidycaesfsts$fst[tidycaesfsts$fst < 0] <- 0
ggcaesfsts <- ggplot(data = tidycaesfsts, aes(x = pop1, y = pop2, fill = fst))
ggcaesfsts +
  geom_tile() +
  scale_fill_gradient(name = expression(F[ST]), low = "white", high = "red", limits = c(0, 0.16)) +
  theme(axis.title = element_text(size = 16),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_rect(colour = "black", fill = NA, size=0.5), 
        axis.text.x = element_text(angle = 45, hjust = 1)) +
  xlab("Location") + ylab("Location")
dev.off()

# 2) G. gemineoa
# Read in file
gem.vcf <- read.vcfR("~/SNPs_gem_SMALL.vcf")
gem.vcf

# Convert to genlight object
gem.gl <- vcfR2genlight(gem.vcf)
gem.gl

# read in pop map and filter for missing individuals
popmap <- read.table("~/popmap.txt")
n <- length(gem.gl$gen) + 1
samples <- names(gem.vcf@gt[1, 2:n])
popdata.gem <- popmap[popmap$V1 %in% samples, ]
pop(gem.gl) <- popdata.gem[ , 2]
gem.gl

# Filter out pops with less than 3 individuals
gem.gl <- gem.gl[gem.gl@pop != names(table(gem.gl@pop)[table(gem.gl@pop) < 3]), ]
gem.gl

# Convert to genind format
gem.gi <- gl2gi(gem.gl)

# Calculate Fsts
gemfsts <- pairwise.fst(gem.gi, res.type = "matrix")
#write.csv(gemfsts, "~/gem_pairwise_fsts.csv")
#gemfsts <- read.csv("gem_pairwise_fsts.csv", row.names = 1)

# Eliminate elements above diagonal (redundant)
ini <- 2
for(i in 1:nrow(gemfsts)){
  if(ini < ncol(gemfsts)+1){
    for(j in ini:ncol(gemfsts)){
      gemfsts[i, j] <- NA
    }
    ini <- ini + 1
  }
}
#

# Convert to long (tify) data table
library(tidyr)
tidygemfsts <- as.data.frame(gemfsts)
tidygemfsts <- cbind(pop1 = rownames(tidygemfsts), tidygemfsts)
tidygemfsts <- gather(tidygemfsts, "pop2", "fst", -pop1, na.rm = TRUE)
#

# Calculate mean fst with se
fsts <- tidygemfsts$fst
fsts[fsts <= 0] <- NA
mean(fsts, na.rm = TRUE)
sd(fsts, na.rm = TRUE)/sqrt(length(fsts))
#

# Change pop names
pop.names <- tidygemfsts[ , 1:2]
library(xlsx)
pop_names.df <- read.xlsx(file = "~/Sampling Sites.xlsx", sheetIndex = 2, rowIndex = 1:31, colIndex = 1:4)
for(j in 1:2){
  for(i in 1:30){
    pop.names[pop.names[ , j] == pop_names.df$Full_ID[i], j] <- pop_names.df$Name[i]
  }
}
tidygemfsts[ , 1:2] <- pop.names
tidygemfsts$pop1 <- as.factor(tidygemfsts$pop1)
tidygemfsts$pop1 <- factor(tidygemfsts$pop1, levels = unique(pop.names$pop1))
tidygemfsts$pop2 <- as.factor(tidygemfsts$pop2)
tidygemfsts$pop2 <- factor(tidygemfsts$pop2, levels = unique(pop.names$pop2))

# Plot Fsts
pdf("~/Fst heatmap gem.pdf", width = 6.2, height = 4.98)
tidygemfsts$fst[tidygemfsts$fst < 0] <- 0
gggemfsts <- ggplot(data = tidygemfsts, aes(x = pop1, y = pop2, fill = fst))
gggemfsts +
  geom_tile() +
  scale_fill_gradient(name = expression(F[ST]), low = "white", high = "red", limits = c(0, 0.16)) +
  theme(axis.title = element_text(size = 16),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_rect(colour = "black", fill = NA, size=0.5), 
        axis.text.x = element_text(angle = 45, hjust = 1)) +
  xlab("Location") + ylab("Location")
dev.off()

################## III. Between species Fsts ##################

# Read gal vcf file and filter out SNPs to reduce size and cpu time
gal.vcf <- read.vcfR("~/SNPs_SMALL.vcf")
dp <- extract.gt(gal.vcf, element = "DP", as.numeric = TRUE)
miss <- apply(dp, MARGIN = 1, function(x){sum(is.na(x))})
miss <- miss/ncol(dp)
summary(miss)
sum(miss < 0.1)
gal.vcf <- gal.vcf[miss < 0.1, ]
gal.vcf

# Covert to genlight object
gal.gl <- vcfR2genlight(gal.vcf)

# read in pop map, filter for missing individuals, and add species suffix to each sample pop label
file <- "~/popmap.txt"
popmap <- read.table(file)
n <- length(gal.gl$gen) + 1
samples <- names(gal.vcf@gt[1, 2:n])
popdata <- popmap[popmap$V1 %in% samples, ]
pops <- as.character(popdata[ , 2])
species.split <- read.csv("~/species_split.csv")
species.split$species[species.split$caes] <- "caes"
species.split$species[species.split$gem] <- "gem"
pops <- paste0(species.split$pop, ".", species.split$species)
pops <- as.factor(pops)
pop(gal.gl) <- pops
#

# Filter pops with less than 2 individuals
gal.gl <- gal.gl[gal.gl$pop %in% names(table(pops))[table(pops) >= 2]]
gal.gl

# Convert to genind object and calculate Fst matrix
gal.gi <- gl2gi(gal.gl)
galfsts <- pairwise.fst(gal.gi, res.type = "matrix")
write.csv(galfsts, "~/fsts.between.species.csv")

# Read in fst matrix
galfsts <- read.csv("~/fsts.between.species.csv", row.names = 1)

#Eliminate alements above diagonal (redundant)
ini <- 2
for(i in 1:nrow(galfsts)){
  if(ini < ncol(galfsts)+1){
    for(j in ini:ncol(galfsts)){
      galfsts[i, j] <- NA
    }
    ini <- ini + 1
  }
}
#

# Fst betwwen the species in sympatric populations
mixed <- c(galfsts[1, 2], galfsts[5, 6], galfsts[10, 11],
           galfsts[15,16], galfsts[20, 21], galfsts[22, 23],
           galfsts[24, 25])
mean(mixed)
sd(mixed)/sqrt(length(mixed))
#

# Calculating Fst separately between both species in sympatric vs allopatric populations
out <- c("P01_G.caes", "P03_AB.caes", "P04_KR.caes", "P07_T.caes", "P06_A.caes", "P07_T.caes", "P08_Q.caes", "P12_CW.caes", "P13_K.caes", "P16_PiB.caes", "P17_NB.caes", "P18_SC.caes", "P25_PeB.caes",
         "P01_G.gem", "P03_AB.gem", "P04_KR.gem", "P07_T.gem", "P06_A.gem", "P07_T.gem", "P08_Q.gem", "P12_CW.gem", "P13_K.gem", "P16_PiB.gem", "P17_NB.gem", "P18_SC.gem", "P25_PeB.gem")

galfstspure <- galfsts[!(rownames(galfsts) %in% out), !(colnames(galfsts) %in% out)]
galfstspure <- galfstspure[9:18, 1:8]
mean(as.matrix(galfstspure))
sd(as.matrix(galfstspure))/sqrt(length(as.matrix(galfstspure)))
#

# Between species Fst heatmap
gem.index <- grep("*.gem", rownames(galfsts))
galfsts.map <- galfsts[gem.index, ]
caes.index <- grep("*.caes", colnames(galfsts))
galfsts.map <- galfsts.map[ , caes.index]
galfsts.map <- galfsts.map[-2, ] #removed P04_KR.gem - it only had 2 individuals and produced a lot of fsts < 0

library(tidyr)
tidygalfsts <- as.data.frame(galfsts.map)
tidygalfsts <- cbind(pop1 = rownames(tidygalfsts), tidygalfsts)
tidygalfsts <- gather(tidygalfsts, "pop2", "fst", -pop1, na.rm = TRUE)
#

# Change pop names
names(tidygalfsts) <- c("gemPop", "caesPop", "fst")
tidygalfsts$gemPop <- unlist(strsplit(tidygalfsts$gemPop, ".gem"))
tidygalfsts$caesPop <- unlist(strsplit(tidygalfsts$caesPop, ".caes"))
pop.names <- tidygalfsts[ , 1:2]
library(xlsx)
pop_names.df <- read.xlsx(file = "~/Sampling Sites.xlsx", sheetIndex = 2, rowIndex = 1:31, colIndex = 1:4)
for(j in 1:2){
  for(i in 1:30){
    pop.names[pop.names[ , j] == pop_names.df$Full_ID[i], j] <- pop_names.df$Name[i]
  }
}
tidygalfsts[ , 1:2] <- pop.names
tidygalfsts$gemPop <- as.factor(tidygalfsts$gemPop)
tidygalfsts$gemPop <- factor(tidygalfsts$gemPop, levels = unique(pop.names$gemPop))
tidygalfsts$caesPop <- as.factor(tidygalfsts$caesPop)
tidygalfsts$caesPop <- factor(tidygalfsts$caesPop, levels = unique(pop.names$caesPop))
tidygalfsts$fst[tidygalfsts$fst < 0] <- 0

# Plot heatmap
# pdf("~/Fst heatmap between species.pdf", width = 6.2, height = 4.98)
fsts <- ggplot(data = tidygalfsts, aes(x = gemPop, y = caesPop, fill = fst))
fsts +
  geom_tile() +
  scale_fill_gradient(name = expression(F[ST]), low = "white", high = "red") +
  theme(axis.title = element_text(size = 16),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_rect(colour = "black", fill = NA, size=0.5), 
        axis.text.x = element_text(angle = 45, hjust = 1)) +
  xlab(expression(italic("G. gemineoa"))) + ylab(expression(italic("G. caespitosa")))
# dev.off()


################## IV. Genetic diversity ##################

# Subset the data sets so that I have the same loci for both species
shared.loci <- intersect(caes.gl@loc.names, gem.gl@loc.names)
caes.gl <- caes.gl[ , caes.gl@loc.names %in% shared.loci]
gem.gl <- gem.gl[ , gem.gl@loc.names %in% shared.loci]
length(intersect(caes.gl@loc.names, gem.gl@loc.names))

# 1) G. caespitosa
# Convert to genind
caes.gi <- gl2gi(caes.gl)

# Convert to hierfstat
caes.hfs <- genind2hierfstat(caes.gi)

# Calculate pop gen statistics
caesbs <- basic.stats(caes.hfs)
caesHo <- colMeans(caesbs$Ho, na.rm = TRUE)
caesHs <- colMeans(caesbs$Hs, na.rm = TRUE)
caesFis <- colMeans(caesbs$Fis, na.rm = TRUE)
n <- as.vector(table(caes.hfs$pop))
write.csv(cbind(n, caesHo, caesHs, caesFis), "~/caes_popgen.csv")
#

# Re-calculate Fis by filtering out loci with heterozygosity > 0.7
loci.het <- rowMeans(caesbs$Ho, na.rm = TRUE)
hist(loci.het) #only one locus with het > 0.7, most have very low het
caesFis.fil <- colMeans(caesbs$Fis[loci.het < 0.7, ], na.rm = TRUE)

# Calculating allelic richness
pops <- as.character(unique(caes.hfs$pop))
arpops <- c()
arSEpops <- c()
for(i in 1:length(pops)){
  arvec <- c()
  for(j in 2:ncol(caes.hfs)){
    vec <- as.character(caes.hfs[caes.hfs$pop == pops[i], j])
    ar <- length(unique(unlist(strsplit(vec, ""))[!is.na(unlist(strsplit(vec, "")))]))
    ar <- if(ar == 0){NA} else{ar}
    arvec <- c(arvec, ar)
  }
  arpops <- c(arpops, mean(arvec, na.rm = TRUE))
  arSEpops <- c(arSEpops, sd(arvec, na.rm = TRUE)/sqrt(length(arvec)))
}
ardfcaes <- data.frame(pop = pops, ar = arpops, se = arSEpops)
#

# 2) G. gemineoa
# Convert to genind
gem.gi <- gl2gi(gem.gl)

# Convert to hierfstat
gem.hfs <- genind2hierfstat(gem.gi)

# Calculate pop gen statistics
gembs <- basic.stats(gem.hfs)
gemHo <- colMeans(gembs$Ho, na.rm = TRUE)
gemHs <- colMeans(gembs$Hs, na.rm = TRUE)
gemFis <- colMeans(gembs$Fis, na.rm = TRUE)
n <- as.vector(table(gem.hfs$pop))
write.csv(cbind(n, gemHo, gemHs, gemFis), "gem_popgen.csv")
#

# Re-calculate Fis by filtering out loci with heterozygosity > 0.7
loci.het <- rowMeans(gembs$Ho, na.rm = TRUE)
sum(loci.het > 0.7)
hist(loci.het) #No loci with het > 0.7, most have very low het
gemFis.fil <- colMeans(gembs$Fis[loci.het < 0.7, ], na.rm = TRUE)

# Calculate allelic richness
pops <- as.character(unique(gem.hfs$pop))
arpops <- c()
arSEpops <- c()
for(i in 1:length(pops)){
  arvec <- c()
  for(j in 2:ncol(gem.hfs)){
    vec <- as.character(gem.hfs[gem.hfs$pop == pops[i], j])
    ar <- length(unique(unlist(strsplit(vec, ""))[!is.na(unlist(strsplit(vec, "")))]))
    ar <- if(ar == 0){NA} else{ar}
    arvec <- c(arvec, ar)
  }
  arpops <- c(arpops, mean(arvec, na.rm = TRUE))
  arSEpops <- c(arSEpops, sd(arvec, na.rm = TRUE)/sqrt(length(arvec)))
}
ardfgem <- data.frame(pop = pops, ar = arpops, se = arSEpops)
#


################## V. Statistical analyses ##################

gendivcaes <- data.frame(species = rep("caes", length(caesHo)), Ho = caesHo, Hs = caesHs, Fis = caesFis, AR = ardfcaes$ar)
gendivgem <- data.frame(species = rep("gem", length(gemHo)), Ho = gemHo, Hs = gemHs, Fis = gemFis, AR = ardfgem$ar)
gendiv <- rbind(gendivcaes, gendivgem)

fit <- lm(Ho ~ species, gendiv)
summary(fit)
par(mfrow=c(2,2))
plot(fit)
anova(fit)

fit <- lm(Hs ~ species, gendiv)
summary(fit)
par(mfrow=c(2,2))
plot(fit)
anova(fit)

fit <- lm(Fis ~ species, gendiv)
summary(fit)
par(mfrow=c(2,2))
plot(fit)
anova(fit)

fit <- lm(AR ~ species, gendiv)
summary(fit)
par(mfrow=c(2,2))
plot(fit)
anova(fit)

tidycaesfsts$fst[tidycaesfsts$fst <= 0] <- NA
tidygemfsts$fst[tidygemfsts$fst <= 0] <- NA
fstwsp <- data.frame(pops = c(rep("caes", length(tidycaesfsts$fst)), rep("gem", length(tidygemfsts$fst))),
                     fst = c(tidycaesfsts$fst, tidygemfsts$fst))
fit <- lm(fst ~ pops, fstwsp)
summary(fit)
par(mfrow=c(2,2))
plot(fit)
anova(fit)

dfsym <- data.frame(pops = rep("gal_gem.sym", length(mixed)), fst = mixed)
allo <- as.vector(as.matrix(galfstspure))
dfallo <- data.frame(pops = rep("gal_gem.allo", length(allo)), fst = allo)
fstbsp <- rbind(dfsym, dfallo)
fit <- lm(fst ~ pops, fstbsp)
summary(fit)
par(mfrow=c(2,2))
plot(fit)
anova(fit)
#

################## VI. MEMGENE (Galpern et al. 2014) ##################
library(ape)
library(memgene)
library(vcfR)
library(adegenet)

#### 1) G. caespitosa ##########################################################

# Load SNPs data
genmat.caes <- read.csv("~/SNPmat_caes_SMALL.csv") #From step 10

# Filter out monomorphic loci
monomorphic <- c()
for(i in 3:ncol(genmat.caes)){
  monomorphic <- c(monomorphic, length(unique(genmat.caes[ , i])[!is.na(unique(genmat.caes[ , i]))]) == 1)
}
sum(monomorphic)
genmat.caes <- genmat.caes[ , c(TRUE, TRUE, !monomorphic)]

# Load lat-long coordinates
coords.caes <- read.csv("~/pop_coordinates.csv")

# Combine data sets
names(genmat.caes)[1] <- "pop"
caes.data <- merge(genmat.caes, coords.caes, by = "pop")
caes.data <- caes.data[ , c(1:2, 5872, 5871, 3:5872)]

# Create objects for positional information and genotypes
caesXY <- caes.data[ , 3:4]
caesGen <- caes.data[ , 5:ncol(caes.data)]

# Get distance matrix
library(hierfstat)
caesDM <- genet.dist(caes.data[ , c(1, 5:ncol(caes.data))], method = "Dch")
caesDM <- as.matrix(caesDM) #population level
caesXY <- data.frame(long = unique(caesXY$long), lat = unique(caesXY$lat)) #population level

# Run MEMGENE
caesMEMGENE <- mgQuick(caesDM, caesXY, longlat = TRUE, forwardPerm = 1000, finalPerm = 100, forwardAlpha = 0.05, doPlot = 2)
# No MEMs are selected, indicating that no significant spatial genetic patterns are present

# Further confirmation
mems <- mgMEM(dist(caesXY)) # Manually get MEMs
mgForward(caesDM, mems[[4]]) # No MEMs selected (non-significant)
rda <- mgRDA(caesDM, mems[[4]], perm = 100) # Manually do rda
rda$RsqAdj # R2 = -Inf
rda$P # p = 1


#### 2) G. gemineoa ##########################################################

# Load SNPs data
genmat.gem <- read.csv("~/SNPmat_gem_SMALL.csv") #From step 10

# Filter out monomorphic loci
monomorphic <- c()
for(i in 3:ncol(genmat.gem)){
  monomorphic <- c(monomorphic, length(unique(genmat.gem[ , i])[!is.na(unique(genmat.gem[ , i]))]) == 1)
}
sum(monomorphic)
genmat.gem <- genmat.gem[ , c(TRUE, TRUE, !monomorphic)]

# Load lat-long coordinates
coords.gem <- read.csv("~/pop_coordinates.csv")

# Combine data sets
names(genmat.gem)[1] <- "pop"
gem.data <- merge(genmat.gem, coords.gem, by = "pop")
gem.data <- gem.data[ , c(1:2, 5353, 5352, 3:5353)]

# Create objects for positional information and genotypes
gemXY <- gem.data[ , 3:4]
gemGen <- gem.data[ , 5:ncol(gem.data)]

# Get distance matrix
library(hierfstat)
gemDM <- genet.dist(gem.data[ , c(1, 5:ncol(gem.data))], method = "Dch")
gemDM <- as.matrix(gemDM) #population level
gemXY <- data.frame(long = unique(gemXY$long), lat = unique(gemXY$lat)) #population level

# Run MEMGENE
gemMEMGENE.pop <- mgQuick(Dgen, popinfo[ , c(3, 2)], longlat = TRUE, forwardPerm = 100, forwardAlpha = 0.05) 
# No significant MEMs when done at population level

# Further confirmation
mems <- mgMEM(dist(gemXY)) # Manually get MEMs
mgForward(gemDM, mems[[4]]) # No MEMs selected (non-significant)
rda <- mgRDA(gemDM, mems[[4]], perm = 100) # Manually do rda
rda$RsqAdj # R2 = -Inf
rda$P # p = 1
