library(gradientForest)

######################### G. caespitosa #############################

# Read SNPs matrix in baypass format
file <- "SNPmat_caes_BIG.csv"
genmat_bp_caes <- read.csv(file)

# Subset candidate loci only
cand_caes <- readLines("candidates_caes_stdcovBF10.txt") # from "9) BayPass to identify candidate loci.R"
genmat_bp_caes <- genmat_bp_caes[genmat_bp_caes$X %in% cand_caes, ]

# Covert SNPs matrix into minor allele frequency (maf) for gradient forest
maf_caes <- data.frame(matrix(NA, nrow = (ncol(genmat_bp_caes)-1)/2, ncol = nrow(genmat_bp_caes)+1))
colnames(maf_caes) <- c("pop", genmat_bp_caes$X)
maf_caes$pop <- colnames(genmat_bp_caes)[2:ncol(genmat_bp_caes)][rep(c(TRUE, FALSE), ncol(genmat_bp_caes)/2)]
snps <- genmat_bp_caes
for(i in 1:nrow(genmat_bp_caes)){
  for(j in 1:((ncol(genmat_bp_caes)-1)/2)){
    allele_counts <- unname(unlist(snps[i, (j*2):(j*2+1)]))
    maf_caes[j, i+1] <- allele_counts[2]/sum(allele_counts)
  }
}
maf_caes[sapply(maf_caes, is.nan)] <- NA

# Write to csv file
write.csv(maf_caes_imp, "CandSNPs_caes_allefreq_stdcovBF10.csv", row.names = FALSE)

# Read csv
genmat.freq.caes <- read.csv("CandSNPs_caes_allefreq_stdcovBF10.csv")

# Read in and prepare environmental predictors matrix
file <- "~/temp_variables.csv"
tempdf <- read.csv(file)
tempdf$pop <- as.character(tempdf$pop)
tempdf <- subset(tempdf, select = c(pop, lat, long, gm, mmr, maxwm, noisecol)) # These are the variables I used to identified candidate loci above
tempdf <- tempdf[tempdf$pop %in% genmat.freq.caes$pop, ]
envmat.caes <- subset(tempdf, select = -c(lat, long))
names(envmat.caes) <- c("pop", "Mean", "Range", "Maximum", "Noise")

# Run gradient forest (GF)
set.seed(21)
gf.caes <- gradientForest(data = cbind(envmat.caes, genmat.freq.caes[ , 2:ncol(genmat.freq.caes)]), predictor.vars = names(envmat.caes)[-c(1)], 
                          response.vars = names(genmat.freq.caes)[-c(1)], ntree = 2000, transform = NULL, compact = FALSE, trace = TRUE)
gf.caes #According to GF, these temperature variables have predictive power for 24 of the 89 SNPs only

# Plot predictor overall importance
plot(gf.caes, plot.type = "O")

# Plot split density
most_important <- names(importance(gf.caes))
par(mgp = c(2, 0.75, 0))
plot(gf.caes, plot.type = "S", imp.vars = most_important, leg.posn = "topright", cex.legend = 0.4, cex.axis = 0.6,
     cex.lab = 0.7, line.ylab = 0.9, par.args = list(mgp = c(1.5, 0.5, 0), mar = c(3.1, 1.5, 0.1, 1)))

# Plot cummulative importance distribution of splits of the first 5 loci
plot(gf.caes, plot.type = "C", imp.vars = most_important, show.overall = F, legend = T, leg.posn = "topleft",
     leg.nspecies = 5, cex.lab = 0.7, cex.legend = 0.4, cex.axis = 0.6, line.ylab = 0.9, 
     par.args = list(mgp = c(1.5, 0.5, 0), mar = c(2.5, 1, 0.1, 0.5), omi = c(0, 0.3, 0, 0)))

# Plot cummulative importance distribution of splits averaged across all loci
plot(gf.caes, plot.type = "C", imp.vars = most_important, show.species = F, common.scale = T, cex.axis = 0.6, cex.lab = 0.7, line.ylab = 0.9, 
     par.args = list(mgp = c(1.5, 0.5, 0), mar = c(2.5, 1, 0.1, 0.5), omi = c(0, 0.3, 0, 0)))

# Plot R^2 of each SNP
dev.off()
plot(gf.caes, plot.type = "P", show.names = F, horizontal = F, cex.axis = 1, cex.labels = 0.7, line = 2.5)

## Use GF model to predict genetic turnover across space

# Read in raster data, crop to SE Australia, and organise in data frame
library(raster)
setwd("~/Present data") # nc files from "9) Get SST data (present and projected).R"
files <- list.files(pattern = "*.nc")
files
sst.present <- stack(files[1:length(files)])
e <- extent(142.06, 150.97, -39.49, -36.04)
sst.present <- crop(sst.present, e)
names(sst.present) <- c("Mean", "Maximum", "Range", "Noise")
env.grid <- data.frame(Mean = values(sst.present[["Mean"]]), Maximum = values(sst.present[["Maximum"]]), 
                       Range = values(sst.present[["Range"]]), Noise = values(sst.present[["Noise"]]))
plot(sst.present[[1]], colNA = "grey97")

# Transform variables by predicting with GF model
imp.vars <- names(importance(gf.caes))
trns_grid_pre <- predict(gf.caes, env.grid[complete.cases(env.grid), imp.vars]) # need to get rid of NA rows or an error pops up

# PCA of the transformed grid for plotting in RGB palette
pca <- prcomp(na.omit(trns_grid_pre), center=TRUE, scale.=FALSE)
summary(pca)
a1 <- pca$x[, 1]
a2 <- pca$x[, 2]
a3 <- pca$x[, 3]
r <- a1 + a2
g <- -a2
b <- a3 + a2 - a1
# Scale colors
r <- (r - min(r))/(max(r) - min(r)) * 255
g <- (g - min(g))/(max(g) - min(g)) * 255
b <- (b - min(b))/(max(b) - min(b)) * 255

# Plot predicted genetic turnover in genetic space (PCA biplot)
nvs <- dim(pca$rotation)[1]
vec <- imp.vars
lv <- length(vec)
vind <- rownames(pca$rotation) %in% vec
scal <- 30
xrng <- range(pca$x[, 1], pca$rotation[, 1]/scal) * 1.1
yrng <- range(pca$x[, 2], pca$rotation[, 2]/scal) * 1.1
trns_site <- predict(gf.caes)
pca.sites <- predict(pca, trns_site[, imp.vars])
jit <- 0.006

# pdf("~/Genetic turnover biplot caes.pdf", width = 5, height = 4)
par(mar=c(4.3, 4.5, 0.5, 0.5))
plot((pca$x[, 1:2]), xlim = xrng, ylim = c(-0.072, 0.028), pch = ".", cex = 4, col = rgb(r, g, b, max = 255), 
     asp = 1, xlab = "PC1 (89.5%)", ylab = "PC2 (9.3%)", cex.lab = 1.5, cex.axis = 0.8)
text(pca$rotation[vec, 1]/scal + jit * sign(pca$rotation[vec, 1]) + c(0, -0.02, 0.015, 0), pca$rotation[vec, 2]/scal + jit * sign(pca$rotation[vec, 2]), labels = vec, cex = 2, font = 2)
points(pca.sites[, 1:2], pch = 21, lwd = 2, cex = 1, bg = "white")
arrows(rep(0, lv), rep(0, lv), pca$rotation[vec, 1]/scal, pca$rotation[vec, 2]/scal, length = 0.0625, lwd = 3)
# dev.off()


# Plot (map) predicted genetic turnover in geographic space
# *PCA is remvoing NAs, so the vector is shorter than it should and it's messing up positions. This code introduces back the NA rows in their original positions
env.grid$x <- 1:nrow(env.grid)
env.grid$nas <- complete.cases(env.grid)
pcs <- as.data.frame(pca$x)
pcs$x <- env.grid$x[env.grid$nas]
pcs <- merge(pcs, env.grid, by = "x", all = TRUE)
pcs$r <- pcs$PC1 + pcs$PC2
pcs$g <- -pcs$PC2
pcs$b <- pcs$PC3 + pcs$PC2 - pcs$PC1
pcs$r <- (pcs$r - min(pcs$r, na.rm = TRUE))/(max(pcs$r, na.rm = TRUE) - min(pcs$r, na.rm = TRUE)) * 255
pcs$g <- (pcs$g - min(pcs$g, na.rm = TRUE))/(max(pcs$g, na.rm = TRUE) - min(pcs$g, na.rm = TRUE)) * 255
pcs$b <- (pcs$b - min(pcs$b, na.rm = TRUE))/(max(pcs$b, na.rm = TRUE) - min(pcs$b, na.rm = TRUE)) * 255
raster.r <- raster.g <- raster.b <- sst.present[[1]]
values(raster.r) <- pcs$r
values(raster.g) <- pcs$g
values(raster.b) <- pcs$b
rgbmap <- stack(raster.r, raster.g, raster.b)

# pdf("~/Genetic turnover map caes.pdf", width = 9.57229, height = 7)
par(mar=c(0, 0, 0, 0))
plotRGB(rgbmap)

# Add points with sampled populations
library(xlsx)
pop.coords <- read.xlsx("~/Samplig Sites.xlsx", sheetIndex = 1, rowIndex = 1:31, colIndex = 4:6)
names(pop.coords) <- c("pop", "lat", "long")
pop.coords <- pop.coords[pop.coords$pop %in% envmat.caes$pop, ]
names(pop.coords)[1] <- "pop"
points(x = pop.coords$long, pop.coords$lat, pch = 21, lwd = 3, cex = 2, bg = "white")
# dev.off()

## Read in projected data to calculate genetic offset (downloaded from: https://www.bio-oracle.org)
# *I'll only use gm and maxwm because those are the variables that I have for both present and future
folder <- "~/Genetic offset/Projected data/"
files <- list.files(folder, pattern = "*.tif")
files
projected <- stack(paste0(folder, files[1:length(files)]))
e <- extent(142.06, 150.97, -39.49, -36.04)
projected <- crop(projected, e)

# Re-sample present raster to match dimensions of projected raster and transform data to genetic space with GF model again
present.pre <- resample(sst.present, projected)
env.pre <- data.frame(Mean = values(present.pre[["Mean"]]), Maximum = values(present.pre[["Maximum"]]))
# trns.pre <- predict(gf.caes, env.pre[complete.cases(env.pre), ])
env.pre$Mean[is.nan(env.pre$Mean)] <- NA
env.pre$Maximum[is.nan(env.pre$Maximum)] <- NA

# Read in australia's border layer
library(rgdal)
library(rgeos)
file <- "~/Australia_boundary.shp" # Downloaded from: https://www.igismap.com/download-australia-administrative-boundary-shapefiles-states-local-government-areas-postal-areas/
australia <- readOGR(dsn = file, layer = "Australia_boundary")
aus_simp <- gSimplify(australia, tol = 0.01, topologyPreserve = TRUE)

# Calculate and map genetic offset for 2050-RCP45
library(viridis)
pro_2050_rcp45 <- projected[[1:2]]
names(pro_2050_rcp45) <- c("Maximum", "Mean")
env.pro <- data.frame(Mean = values(pro_2050_rcp45[["Mean"]]), Maximum = values(pro_2050_rcp45[["Maximum"]]))
# Match NAs in present and projected data
env.pre$Mean[is.na(env.pro$Mean)] <- NA
env.pre$Maximum[is.na(env.pro$Maximum)] <- NA
env.pro$Mean[is.na(env.pre$Mean)] <- NA
env.pro$Maximum[is.na(env.pre$Maximum)] <- NA
#
trns.pre <- predict(gf.caes, env.pre[complete.cases(env.pre), ])
trns.pro <- predict(gf.caes, env.pro[complete.cases(env.pro), ])
genOff <- sqrt((trns.pro[ , "Maximum"] - trns.pre[ , "Maximum"])^2 + (trns.pro[ , "Mean"] - trns.pre[ , "Mean"])^2)
genOffMap <- pro_2050_rcp45[[1]]
# Put back NA rows
dummydf <- data.frame(x = 1:length(values(genOffMap)), NAs = complete.cases(env.pro))
genOffdf <- as.data.frame(genOff)
genOffdf$x <- dummydf$x[dummydf$NAs]
genOffdf <- merge(genOffdf, dummydf, by = "x", all = TRUE)
#
values(genOffMap) <- genOffdf$genOff
# pdf("~/Gen Offset 2050-RCP45 caes.pdf", width = 6.81*1.5, height = 4.98*1.5)
plot(genOffMap, main = "Gentic Offset 2050-RCP45", colNA = "grey97", col = viridis(100), zlim=c(0, 0.1))
plot(aus_simp, add = TRUE)
points(x = pop.coords$long, pop.coords$lat, pch = 21, lwd = 3, cex = 2, bg = "white")
# dev.off()

# Calculate and map genetic offset for 2050-RCP85
pro_2050_rcp85 <- projected[[5:6]]
names(pro_2050_rcp85) <- c("Maximum", "Mean")
env.pro <- data.frame(Mean = values(pro_2050_rcp85[["Mean"]]), Maximum = values(pro_2050_rcp85[["Maximum"]]))
# Match NAs in present and projected data
env.pre$Mean[is.na(env.pro$Mean)] <- NA
env.pre$Maximum[is.na(env.pro$Maximum)] <- NA
env.pro$Mean[is.na(env.pre$Mean)] <- NA
env.pro$Maximum[is.na(env.pre$Maximum)] <- NA
#
trns.pre <- predict(gf.caes, env.pre[complete.cases(env.pre), ])
trns.pro <- predict(gf.caes, env.pro[complete.cases(env.pro), ])
genOff <- sqrt((trns.pro[ , "Maximum"] - trns.pre[ , "Maximum"])^2 + (trns.pro[ , "Mean"] - trns.pre[ , "Mean"])^2)
genOffMap <- pro_2050_rcp85[[1]]
# Put back NA rows
dummydf <- data.frame(x = 1:length(values(genOffMap)), NAs = complete.cases(env.pro))
genOffdf <- as.data.frame(genOff)
genOffdf$x <- dummydf$x[dummydf$NAs]
genOffdf <- merge(genOffdf, dummydf, by = "x", all = TRUE)
#
values(genOffMap) <- genOffdf$genOff
# pdf("~/Gen Offset 2050-RCP85 caes.pdf", width = 6.81*1.5, height = 4.98*1.5)
plot(genOffMap, main = "Gentic Offset 2050-RCP85", colNA = "grey97", col = viridis(100), zlim=c(0, 0.1))
plot(aus_simp, add = TRUE)
points(x = pop.coords$long, pop.coords$lat, pch = 21, lwd = 3, cex = 2, bg = "white")
# dev.off()

# Calculate and map genetic offset for 2100-RCP45
pro_2100_rcp45 <- projected[[7:8]]
names(pro_2100_rcp45) <- c("Maximum", "Mean")
env.pro <- data.frame(Mean = values(pro_2100_rcp45[["Mean"]]), Maximum = values(pro_2100_rcp45[["Maximum"]]))
# Match NAs in present and projected data
env.pre$Mean[is.na(env.pro$Mean)] <- NA
env.pre$Maximum[is.na(env.pro$Maximum)] <- NA
env.pro$Mean[is.na(env.pre$Mean)] <- NA
env.pro$Maximum[is.na(env.pre$Maximum)] <- NA
#
trns.pre <- predict(gf.caes, env.pre[complete.cases(env.pre), ])
trns.pro <- predict(gf.caes, env.pro[complete.cases(env.pro), ])
genOff <- sqrt((trns.pro[ , "Maximum"] - trns.pre[ , "Maximum"])^2 + (trns.pro[ , "Mean"] - trns.pre[ , "Mean"])^2)
genOffMap <- pro_2100_rcp45[[1]]
# Put back NA rows
dummydf <- data.frame(x = 1:length(values(genOffMap)), NAs = complete.cases(env.pro))
genOffdf <- as.data.frame(genOff)
genOffdf$x <- dummydf$x[dummydf$NAs]
genOffdf <- merge(genOffdf, dummydf, by = "x", all = TRUE)
#
values(genOffMap) <- genOffdf$genOff
# pdf("~/Gen Offset 2100-RCP45 caes.pdf", width = 6.81*1.5, height = 4.98*1.5)
plot(genOffMap, main = "Gentic Offset 2100-RCP45", colNA = "grey97", col = viridis(100), zlim=c(0, 0.1))
plot(aus_simp, add = TRUE)
points(x = pop.coords$long, pop.coords$lat, pch = 21, lwd = 3, cex = 2, bg = "white")
# dev.off()

# Calculate and map genetic offset for 2100-RCP85
pro_2100_rcp85 <- projected[[11:12]]
names(pro_2100_rcp85) <- c("Maximum", "Mean")
env.pro <- data.frame(Mean = values(pro_2100_rcp85[["Mean"]]), Maximum = values(pro_2100_rcp85[["Maximum"]]))
# Match NAs in present and projected data
env.pre$Mean[is.na(env.pro$Mean)] <- NA
env.pre$Maximum[is.na(env.pro$Maximum)] <- NA
env.pro$Mean[is.na(env.pre$Mean)] <- NA
env.pro$Maximum[is.na(env.pre$Maximum)] <- NA
#
trns.pre <- predict(gf.caes, env.pre[complete.cases(env.pre), ])
trns.pro <- predict(gf.caes, env.pro[complete.cases(env.pro), ])
genOff <- sqrt((trns.pro[ , "Maximum"] - trns.pre[ , "Maximum"])^2 + (trns.pro[ , "Mean"] - trns.pre[ , "Mean"])^2)
genOffMap <- pro_2100_rcp85[[1]]
# Put back NA rows
dummydf <- data.frame(x = 1:length(values(genOffMap)), NAs = complete.cases(env.pro))
genOffdf <- as.data.frame(genOff)
genOffdf$x <- dummydf$x[dummydf$NAs]
genOffdf <- merge(genOffdf, dummydf, by = "x", all = TRUE)
#
values(genOffMap) <- genOffdf$genOff
# pdf("~/Gen Offset 2100-RCP85 caes.pdf", width = 6.81*1.5, height = 4.98*1.5)
plot(genOffMap, main = "Gentic Offset 2100-RCP85", colNA = "grey97", col = viridis(100), zlim=c(0, 0.1))
plot(aus_simp, add = TRUE)
points(x = pop.coords$long, pop.coords$lat, pch = 21, lwd = 3, cex = 2, bg = "white")
# dev.off()

# Plot legend
# pdf("~/caes legend 2.pdf", width = 10, height = 4.98)
par(oma = c(5, 1, 1, 1))
plot(genOffMap, legend.only = TRUE, col = viridis(100), zlim=c(0, 0.1), legend.width = 1.5, legend.shrink = 1, 
     legend.args = list(text = 'Genetic offset', side = 1, font = 1, line = 3, cex = 1.2), horizontal = TRUE)
# dev.off()




######################### G. gemineoa #############################

# Read SNPs matrix in baypass format
file <- "SNPmat_gem_BIG.csv"
genmat_bp_gem <- read.csv(file)

# Subset candidate loci only
cand_gem <- readLines("candidates_gem_stdcovBF10.txt") # from "9) BayPass to identify candidate loci.R"
genmat_bp_gem <- genmat_bp_gem[genmat_bp_gem$X %in% cand_gem, ]

# Covert SNPs matrix into minor allele frequency (maf) for gradient forest
maf_gem <- data.frame(matrix(NA, nrow = (ncol(genmat_bp_gem)-1)/2, ncol = nrow(genmat_bp_gem)+1))
colnames(maf_gem) <- c("pop", genmat_bp_gem$X)
maf_gem$pop <- colnames(genmat_bp_gem)[2:ncol(genmat_bp_gem)][rep(c(TRUE, FALSE), ncol(genmat_bp_gem)/2)]
snps <- genmat_bp_gem
for(i in 1:nrow(genmat_bp_gem)){
  for(j in 1:((ncol(genmat_bp_gem)-1)/2)){
    allele_counts <- unname(unlist(snps[i, (j*2):(j*2+1)]))
    maf_gem[j, i+1] <- allele_counts[2]/sum(allele_counts)
  }
}
maf_gem[sapply(maf_gem, is.nan)] <- NA

# Write to csv file
write.csv(maf_gem_imp, "CandSNPs_gem_allefreq_stdcovBF10.csv", row.names = FALSE)

# Read csv
genmat.freq.gem <- read.csv("CandSNPs_gem_allefreq_stdcovBF10.csv")

# Read in and prepare environmental predictors matrix
file <- "~/temp_variables.csv"
tempdf <- read.csv(file)
tempdf$pop <- as.character(tempdf$pop)
tempdf <- subset(tempdf, select = c(pop, lat, long, gm, mmr, maxwm, noisecol)) # These are the variables I used to identified candidate loci above
tempdf <- tempdf[tempdf$pop %in% genmat.freq.gem$pop, ]
envmat.gem <- subset(tempdf, select = -c(lat, long))
names(envmat.gem) <- c("pop", "Mean", "Range", "Maximum", "Noise")

# Run gradient forest (GF)
set.seed(21)
gf.gem <- gradientForest(data = cbind(envmat.gem, genmat.freq.gem[ , 2:ncol(genmat.freq.gem)]), predictor.vars = names(envmat.gem)[-c(1)], 
                          response.vars = names(genmat.freq.gem)[-c(1)], ntree = 2000, transform = NULL, compact = FALSE, trace = TRUE)
gf.gem #According to GF, these temperature variables have predictive power for 24 of the 89 SNPs only

# Plot predictor overall importance
plot(gf.gem, plot.type = "O")

# Plot split density
most_important <- names(importance(gf.gem))
par(mgp = c(2, 0.75, 0))
plot(gf.gem, plot.type = "S", imp.vars = most_important, leg.posn = "topright", cex.legend = 0.4, cex.axis = 0.6,
     cex.lab = 0.7, line.ylab = 0.9, par.args = list(mgp = c(1.5, 0.5, 0), mar = c(3.1, 1.5, 0.1, 1)))

# Plot cummulative importance distribution of splits of the first 5 loci
plot(gf.gem, plot.type = "C", imp.vars = most_important, show.overall = F, legend = T, leg.posn = "topleft",
     leg.nspecies = 5, cex.lab = 0.7, cex.legend = 0.4, cex.axis = 0.6, line.ylab = 0.9, 
     par.args = list(mgp = c(1.5, 0.5, 0), mar = c(2.5, 1, 0.1, 0.5), omi = c(0, 0.3, 0, 0)))

# Plot cummulative importance distribution of splits averaged across all loci
plot(gf.gem, plot.type = "C", imp.vars = most_important, show.species = F, common.scale = T, cex.axis = 0.6, cex.lab = 0.7, line.ylab = 0.9, 
     par.args = list(mgp = c(1.5, 0.5, 0), mar = c(2.5, 1, 0.1, 0.5), omi = c(0, 0.3, 0, 0)))

# Plot R^2 of each SNP
dev.off()
plot(gf.gem, plot.type = "P", show.names = F, horizontal = F, cex.axis = 1, cex.labels = 0.7, line = 2.5)

## Use GF model to predict genetic turnover across space

# Read in raster data, crop to SE Australia, and organise in data frame
library(raster)
setwd("~Present data")
files <- list.files(pattern = "*.nc")
files
sst.present <- stack(files[1:length(files)])
e <- extent(142.06, 150.97, -39.49, -36.04)
sst.present <- crop(sst.present, e)
names(sst.present) <- c("Mean", "Maximum", "Range", "Noise")
env.grid <- data.frame(Mean = values(sst.present[["Mean"]]), Maximum = values(sst.present[["Maximum"]]), 
                       Range = values(sst.present[["Range"]]), Noise = values(sst.present[["Noise"]]))
plot(sst.present[[1]], colNA = "grey97")

# Transform variables by predicting with GF model
imp.vars <- names(importance(gf.gem))
trns_grid_pre <- predict(gf.gem, env.grid[complete.cases(env.grid), imp.vars]) # need to get rid of NA rows or an error pops up

# PCA of the transformed grid for plotting in RGB palette
pca <- prcomp(na.omit(trns_grid_pre), center=TRUE, scale.=FALSE)
summary(pca)
a1 <- pca$x[, 1]
a2 <- pca$x[, 2]
a3 <- pca$x[, 3]
r <- a1 + a2
g <- -a2
b <- a3 + a2 - a1
# Scale colors
r <- (r - min(r))/(max(r) - min(r)) * 255
g <- (g - min(g))/(max(g) - min(g)) * 255
b <- (b - min(b))/(max(b) - min(b)) * 255

# Plot predicted genetic turnover in genetic space (PCA biplot)
nvs <- dim(pca$rotation)[1]
vec <- imp.vars
lv <- length(vec)
vind <- rownames(pca$rotation) %in% vec
scal <- 30
xrng <- range(pca$x[, 1], pca$rotation[, 1]/scal) * 1.1
yrng <- range(pca$x[, 2], pca$rotation[, 2]/scal) * 1.1
trns_site <- predict(gf.gem)
pca.sites <- predict(pca, trns_site[, imp.vars])
jit <- 0.006

# pdf("~/Genetic turnover biplot gem.pdf", width = 5, height = 4)
par(mar=c(4.3, 4.5, 0.5, 0.5))
plot((pca$x[, 1:2]), xlim = xrng, ylim = c(-0.072, 0.028), pch = ".", cex = 4, col = rgb(r, g, b, max = 255), 
     asp = 1, xlab = "PC1 (89.5%)", ylab = "PC2 (9.3%)", cex.lab = 1.5, cex.axis = 0.8)
text(pca$rotation[vec, 1]/scal + jit * sign(pca$rotation[vec, 1]) + c(0, -0.02, 0.015, 0), pca$rotation[vec, 2]/scal + jit * sign(pca$rotation[vec, 2]), labels = vec, cex = 2, font = 2)
points(pca.sites[, 1:2], pch = 21, lwd = 2, cex = 1, bg = "white")
arrows(rep(0, lv), rep(0, lv), pca$rotation[vec, 1]/scal, pca$rotation[vec, 2]/scal, length = 0.0625, lwd = 3)
# dev.off()


# Plot (map) predicted genetic turnover in geographic space
# *PCA is remvoing NAs, so the vector is shorter than it should and it's messing up positions. This code introduces back the NA rows in their original positions
env.grid$x <- 1:nrow(env.grid)
env.grid$nas <- complete.cases(env.grid)
pcs <- as.data.frame(pca$x)
pcs$x <- env.grid$x[env.grid$nas]
pcs <- merge(pcs, env.grid, by = "x", all = TRUE)
pcs$r <- pcs$PC1 + pcs$PC2
pcs$g <- -pcs$PC2
pcs$b <- pcs$PC3 + pcs$PC2 - pcs$PC1
pcs$r <- (pcs$r - min(pcs$r, na.rm = TRUE))/(max(pcs$r, na.rm = TRUE) - min(pcs$r, na.rm = TRUE)) * 255
pcs$g <- (pcs$g - min(pcs$g, na.rm = TRUE))/(max(pcs$g, na.rm = TRUE) - min(pcs$g, na.rm = TRUE)) * 255
pcs$b <- (pcs$b - min(pcs$b, na.rm = TRUE))/(max(pcs$b, na.rm = TRUE) - min(pcs$b, na.rm = TRUE)) * 255
raster.r <- raster.g <- raster.b <- sst.present[[1]]
values(raster.r) <- pcs$r
values(raster.g) <- pcs$g
values(raster.b) <- pcs$b
rgbmap <- stack(raster.r, raster.g, raster.b)

# pdf("~/Genetic turnover map gem.pdf", width = 9.57229, height = 7)
par(mar=c(0, 0, 0, 0))
plotRGB(rgbmap)

# Add points with sampled populations
library(xlsx)
pop.coords <- read.xlsx("~/Samplig Sites.xlsx", sheetIndex = 1, rowIndex = 1:31, colIndex = 4:6)
names(pop.coords) <- c("pop", "lat", "long")
pop.coords <- pop.coords[pop.coords$pop %in% envmat.gem$pop, ]
names(pop.coords)[1] <- "pop"
points(x = pop.coords$long, pop.coords$lat, pch = 21, lwd = 3, cex = 2, bg = "white")
# dev.off()

## Read in projected data to calculate genetic offset
# *I'll only use gm and maxwm because those are the variables that I have for both present and future
folder <- "~/Genetic offset/Projected data/"
files <- list.files(folder, pattern = "*.tif")
files
projected <- stack(paste0(folder, files[1:length(files)]))
e <- extent(142.06, 150.97, -39.49, -36.04)
projected <- crop(projected, e)

# Re-sample present raster to match dimensions of projected raster and transform data to genetic space with GF model again
present.pre <- resample(sst.present, projected)
env.pre <- data.frame(Mean = values(present.pre[["Mean"]]), Maximum = values(present.pre[["Maximum"]]))
# trns.pre <- predict(gf.gem, env.pre[complete.cases(env.pre), ])
env.pre$Mean[is.nan(env.pre$Mean)] <- NA
env.pre$Maximum[is.nan(env.pre$Maximum)] <- NA

# Read in australia's border layer
library(rgdal)
library(rgeos)
file <- "~/Australia_boundary.shp" # Downloaded from: https://www.igismap.com/download-australia-administrative-boundary-shapefiles-states-local-government-areas-postal-areas/
australia <- readOGR(dsn = file, layer = "Australia_boundary")
aus_simp <- gSimplify(australia, tol = 0.01, topologyPreserve = TRUE)

# Calculate and map genetic offset for 2050-RCP45
library(viridis)
pro_2050_rcp45 <- projected[[1:2]]
names(pro_2050_rcp45) <- c("Maximum", "Mean")
env.pro <- data.frame(Mean = values(pro_2050_rcp45[["Mean"]]), Maximum = values(pro_2050_rcp45[["Maximum"]]))
# Match NAs in present and projected data
env.pre$Mean[is.na(env.pro$Mean)] <- NA
env.pre$Maximum[is.na(env.pro$Maximum)] <- NA
env.pro$Mean[is.na(env.pre$Mean)] <- NA
env.pro$Maximum[is.na(env.pre$Maximum)] <- NA
#
trns.pre <- predict(gf.gem, env.pre[complete.cases(env.pre), ])
trns.pro <- predict(gf.gem, env.pro[complete.cases(env.pro), ])
genOff <- sqrt((trns.pro[ , "Maximum"] - trns.pre[ , "Maximum"])^2 + (trns.pro[ , "Mean"] - trns.pre[ , "Mean"])^2)
genOffMap <- pro_2050_rcp45[[1]]
# Put back NA rows
dummydf <- data.frame(x = 1:length(values(genOffMap)), NAs = complete.cases(env.pro))
genOffdf <- as.data.frame(genOff)
genOffdf$x <- dummydf$x[dummydf$NAs]
genOffdf <- merge(genOffdf, dummydf, by = "x", all = TRUE)
#
values(genOffMap) <- genOffdf$genOff
# pdf("~/Gen Offset 2050-RCP45 gem.pdf", width = 6.81*1.5, height = 4.98*1.5)
plot(genOffMap, main = "Gentic Offset 2050-RCP45", colNA = "grey97", col = viridis(100), zlim=c(0, 0.1))
plot(aus_simp, add = TRUE)
points(x = pop.coords$long, pop.coords$lat, pch = 21, lwd = 3, cex = 2, bg = "white")
# dev.off()

# Calculate and map genetic offset for 2050-RCP85
pro_2050_rcp85 <- projected[[5:6]]
names(pro_2050_rcp85) <- c("Maximum", "Mean")
env.pro <- data.frame(Mean = values(pro_2050_rcp85[["Mean"]]), Maximum = values(pro_2050_rcp85[["Maximum"]]))
# Match NAs in present and projected data
env.pre$Mean[is.na(env.pro$Mean)] <- NA
env.pre$Maximum[is.na(env.pro$Maximum)] <- NA
env.pro$Mean[is.na(env.pre$Mean)] <- NA
env.pro$Maximum[is.na(env.pre$Maximum)] <- NA
#
trns.pre <- predict(gf.gem, env.pre[complete.cases(env.pre), ])
trns.pro <- predict(gf.gem, env.pro[complete.cases(env.pro), ])
genOff <- sqrt((trns.pro[ , "Maximum"] - trns.pre[ , "Maximum"])^2 + (trns.pro[ , "Mean"] - trns.pre[ , "Mean"])^2)
genOffMap <- pro_2050_rcp85[[1]]
# Put back NA rows
dummydf <- data.frame(x = 1:length(values(genOffMap)), NAs = complete.cases(env.pro))
genOffdf <- as.data.frame(genOff)
genOffdf$x <- dummydf$x[dummydf$NAs]
genOffdf <- merge(genOffdf, dummydf, by = "x", all = TRUE)
#
values(genOffMap) <- genOffdf$genOff
# pdf("~/Gen Offset 2050-RCP85 gem.pdf", width = 6.81*1.5, height = 4.98*1.5)
plot(genOffMap, main = "Gentic Offset 2050-RCP85", colNA = "grey97", col = viridis(100), zlim=c(0, 0.1))
plot(aus_simp, add = TRUE)
points(x = pop.coords$long, pop.coords$lat, pch = 21, lwd = 3, cex = 2, bg = "white")
# dev.off()

# Calculate and map genetic offset for 2100-RCP45
pro_2100_rcp45 <- projected[[7:8]]
names(pro_2100_rcp45) <- c("Maximum", "Mean")
env.pro <- data.frame(Mean = values(pro_2100_rcp45[["Mean"]]), Maximum = values(pro_2100_rcp45[["Maximum"]]))
# Match NAs in present and projected data
env.pre$Mean[is.na(env.pro$Mean)] <- NA
env.pre$Maximum[is.na(env.pro$Maximum)] <- NA
env.pro$Mean[is.na(env.pre$Mean)] <- NA
env.pro$Maximum[is.na(env.pre$Maximum)] <- NA
#
trns.pre <- predict(gf.gem, env.pre[complete.cases(env.pre), ])
trns.pro <- predict(gf.gem, env.pro[complete.cases(env.pro), ])
genOff <- sqrt((trns.pro[ , "Maximum"] - trns.pre[ , "Maximum"])^2 + (trns.pro[ , "Mean"] - trns.pre[ , "Mean"])^2)
genOffMap <- pro_2100_rcp45[[1]]
# Put back NA rows
dummydf <- data.frame(x = 1:length(values(genOffMap)), NAs = complete.cases(env.pro))
genOffdf <- as.data.frame(genOff)
genOffdf$x <- dummydf$x[dummydf$NAs]
genOffdf <- merge(genOffdf, dummydf, by = "x", all = TRUE)
#
values(genOffMap) <- genOffdf$genOff
# pdf("~/Gen Offset 2100-RCP45 gem.pdf", width = 6.81*1.5, height = 4.98*1.5)
plot(genOffMap, main = "Gentic Offset 2100-RCP45", colNA = "grey97", col = viridis(100), zlim=c(0, 0.1))
plot(aus_simp, add = TRUE)
points(x = pop.coords$long, pop.coords$lat, pch = 21, lwd = 3, cex = 2, bg = "white")
# dev.off()

# Calculate and map genetic offset for 2100-RCP85
pro_2100_rcp85 <- projected[[11:12]]
names(pro_2100_rcp85) <- c("Maximum", "Mean")
env.pro <- data.frame(Mean = values(pro_2100_rcp85[["Mean"]]), Maximum = values(pro_2100_rcp85[["Maximum"]]))
# Match NAs in present and projected data
env.pre$Mean[is.na(env.pro$Mean)] <- NA
env.pre$Maximum[is.na(env.pro$Maximum)] <- NA
env.pro$Mean[is.na(env.pre$Mean)] <- NA
env.pro$Maximum[is.na(env.pre$Maximum)] <- NA
#
trns.pre <- predict(gf.gem, env.pre[complete.cases(env.pre), ])
trns.pro <- predict(gf.gem, env.pro[complete.cases(env.pro), ])
genOff <- sqrt((trns.pro[ , "Maximum"] - trns.pre[ , "Maximum"])^2 + (trns.pro[ , "Mean"] - trns.pre[ , "Mean"])^2)
genOffMap <- pro_2100_rcp85[[1]]
# Put back NA rows
dummydf <- data.frame(x = 1:length(values(genOffMap)), NAs = complete.cases(env.pro))
genOffdf <- as.data.frame(genOff)
genOffdf$x <- dummydf$x[dummydf$NAs]
genOffdf <- merge(genOffdf, dummydf, by = "x", all = TRUE)
#
values(genOffMap) <- genOffdf$genOff
# pdf("~/Gen Offset 2100-RCP85 gem.pdf", width = 6.81*1.5, height = 4.98*1.5)
plot(genOffMap, main = "Gentic Offset 2100-RCP85", colNA = "grey97", col = viridis(100), zlim=c(0, 0.1))
plot(aus_simp, add = TRUE)
points(x = pop.coords$long, pop.coords$lat, pch = 21, lwd = 3, cex = 2, bg = "white")
# dev.off()

# Plot legend
# pdf("~/gem legend 2.pdf", width = 10, height = 4.98)
par(oma = c(5, 1, 1, 1))
plot(genOffMap, legend.only = TRUE, col = viridis(100), zlim=c(0, 0.1), legend.width = 1.5, legend.shrink = 1, 
     legend.args = list(text = 'Genetic offset', side = 1, font = 1, line = 3, cex = 1.2), horizontal = TRUE)
# dev.off()



