##### I) Download and extract sea surface temperature (SST) data (adapted from code by Pieter Arnold) #####

library(curl)
library(ncdf4)
library(RCurl)
library(R.utils)
library(httr)
library(purrr)
library(dplyr)
library(raster)
library(weathermetrics)
library(tidyr)
library(ggplot2)

setwd("D:/SST data/2018/2018-07")                               # INPUT: change working directory as desired
# Define year and month of dataset downloading and extracting SSTs
year   <- 2018        
month  <- "08"                                                                       ## INPUT

setdays <- function(){
  if (month == "01" || month == "03" || month == "05" || month == "07"
      || month == "08" || month == "10" || month == "12") {
    day <- seq(1, 31, 1)   # JANUARY, MARCH, MAY, JULY, AUGUST, OCTOBER, DECEMBER
  } else if (month == "04" || month == "06" || month == "09" || month == "11") {
    day <- seq(1, 30, 1)   # APRIL, JUNE, SEPTEMBER, NOVEMBER
  } else if (month == "02" && year %% 4 == 0)  {
    day <- seq(1, 29, 1) 
  } else if (month == "02") {
    day <- seq(1, 28, 1)
  } 
  day <- formatC(day, width = 2, format = "d", flag = "0")
  print(day)
  
  # Workaround for leap years
  if (year %% 4 == 0) {
    url_date <<- seq(1, 366, 1)
  } else url_date <<- seq(1, 365, 1)
  print(max(url_date))
  
  days <- day[1:31]
  days <<- days[!is.na(days)]
  days
}

setdays()

# Set the name of the final URL segment and the day with appropriate zeros in front
# This also sets which files and the total number of files to download
# Specify days of the month
# Define number of days in the month based on the month defined above (if less than the whole month)
# NB: sometimes the server denies access to certain files for seemingly no reason
#     if this happens, move on and download the next batch without the problem file
#     then go back to the problem file individually later


# Check ftp server file directory and set this value for where 
# the first of the files for the month to download starts
# For example: seq(1, (1+length(days)-1), 1) where days <- day[1:31] will run through all of January
# and seq(61, (61+length(days)-1), 1) where days <- day[1:30] will run through all of March in a leap year
# i.e. the folders in the ftp server use Julian date rather than calendar date, but we write the files as 
# the calendar date but have to set the download by Julian date.
# ftp://ftp.nodc.noaa.gov/pub/data.nodc/ghrsst/L4/GLOB/JPL_OUROCEAN/G1SST/

## This is to know the day number of any chosen date (INPUT: all dates below)
chosen_date <- as.Date("2018-08-01") ##INPUT
dates <- seq(as.Date("2018-01-01"), as.Date("2018-12-31"), by="days") #change year only
day_numbers <- as.data.frame(url_date)
day_numbers$dates <- dates
day_numbers[day_numbers$dates == chosen_date, 1]
inday <- day_numbers[day_numbers$dates == chosen_date, 1]
##

url_name <- seq(inday, (inday+length(days)-1), 1)                                                      ## INPUT: change initial day
url_name <- formatC(url_name, width = 3, format = "d", flag = "0")                              
url_name

day_name <- formatC(url_name, width = 2, format = "d", flag = "0")
day_name

# do the number of days and number of files to download match? If not, check url_name and day_name above
length(days) : length(url_name) 

Sys.time()
# Set URLs, download files from set URLs and write to working directory
for(i in 1:length(url_name)){
  url <- paste0("ftp://ftp.nodc.noaa.gov/pub/data.nodc/ghrsst/L4/GLOB/JPL_OUROCEAN/G1SST/", 
                year, "/", url_name[i], "/")
  curl = getCurlHandle()
  curlSetOpt(.opts = list(forbid.reuse = 1), curl = curl) 
  filenames = getURL(url, ftp.use.epsv = FALSE, dirlistonly = TRUE, crlf = TRUE, ssl.verifypeer = FALSE, 
                     curl = curl)
  filenames = paste(url, strsplit(filenames, "\r*\n")[[1]], sep = "")
  filenamesNC = filenames[1] # subset only the netcdf files
  download.file(url = filenamesNC, mode = "wb", method = "wininet",
                destfile = paste0(year, month, days[i], 
                                  "-JPL_OUROCEAN-L4UHfnd-GLOB-v01-fv01_0-G1SST.nc.bz2"))
  rm(curl)
  gc()	
  Sys.sleep(3)
}

# Unzip the .bz files
bzfolder <- "D:/SST data/2018/2018-08"                        # INPUT: change destination of bzfolder as desired
bzfiles  <- list.files(bzfolder, pattern = "*.bz2", full.names = T)
n_zip    <- length(bzfiles)
for (i in 1:n_zip) {
  bunzip2(bzfiles[i], destname = gsub("[.]bz2$", "", bzfiles[i]), overwrite=FALSE, remove=FALSE)
}


###### II) Create variables ######

# Trim nc files to south east Australia
library(raster)
library(weathermetrics)

for(i in 2011:2018){
  year <- i
  for(j in 1:12){
    month <- j
    month <- formatC(month, width = 2, format = "d", flag = "0")
    
    setwd(paste0("~/Small ncFiles/", year, "/", year, "-", month))
    
    ncfolder <- paste0("D:/SST data/", year, "/", year, "-", month)     
    files <- list.files(ncfolder, pattern = "*.nc$", full.names = T)
    e <- extent(134.076, 156, -44.25, -35.273)
    
    for(i in 1:length(files)){
      aux1 <-  raster(files[i])
      aux1 <- crop(aux1, e)
      values(aux1) <- kelvin.to.celsius(values(aux1))
      start <- sum(regexpr(paste0(year, "-", month, "/"), files[i])[1] + 8)                             
      stop <- start + 7
      date <- substr(files[i], start, stop)
      writeRaster(aux1, paste0("SSTAus_", date, ".nc"), format = "CDF", overwrite = TRUE)
    }
  }
}

# Stack all rasters
library(raster)
library(tidyr)
library(RColorBrewer)
library(grDevices)
library(mapplots)

stack <- stack()
for (year in 2010:2019){
  if(year == 2010){
    ini <- 7
    end <- 12
  } else if (year == 2019) {
    ini <- 1
    end <- 8
  } else {
    ini <- 1
    end <- 12
  }
  for (j in ini:end){
    month <- j
    month <- formatC(month, width = 2, format = "d", flag = "0")
    days <- formatC(1:31, width = 2, format = "d", flag = "0")
    ncfolder <- paste("~/Small ncFiles/", year, "/", year, "-", month, sep = "")
    files <- list.files(ncfolder, pattern = "*.nc$", full.names = T)
    map <- stack(files[1:length(files)])
    #val <- values(map) #This lines check if there are any values less than 0 (an error in the data that sometimes occur)
    #val[val < 0] <- NA #and replaces them with NAs, before adding the layers to the main stack
    #values(map) <- val
    #rm(val)
    stack <- addLayer(stack, map)
    rm(map)
    print(paste("year", year, "month", month, "done"))
  }
}

#writeRaster(stack, "C~/SSTAU_stack.nc", format = "CDF")

## This datemap let me sample the stack by the desire years, months, or days by then creating an index
dates <- seq(as.Date("2010-07-01"), as.Date("2019-08-27"), by="days")
dayn <- 1:length(dates)
datemap <- data.frame(dates, dayn)
datemap <- separate(datemap, col = dates, into = c("year", "month", "day"), sep = "-", remove = FALSE)
#names(stack) <- as.character(datemap$dates)
#

## 0) The grand mean (2011-2018) (GM)
gm <- mean(stack[[185:3106]], na.rm = TRUE)
writeRaster(gm, paste(src, "/Data/gm.nc", sep = ""), format = "CDF", overwrite = TRUE)
min(values(gm), na.rm = TRUE)
max(values(gm), na.rm = TRUE)

## I) Trend: changes in temperature 2018 vs 2011
### 1) Average of 2011 and 2018 and look at the difference in temperature.

index2011 <- datemap$dayn[datemap$year == "2011"]
mean2011 <- mean(stack[[index2011]])

index2018 <- datemap$dayn[datemap$year == "2018"]
mean2018 <- mean(stack[[index2018]])

trend <- mean2018 - mean2011
writeRaster(trend, "~/Data/T18-T11.nc", format = "CDF")


### 2) Difference between summer and winter
#### *NOTE: Following BIOCLIM I'll define summer as the warmest quarter and winter as the coldest quarter. This makes sense
####        as seasons in the ocean lag behind seasons in the air due to water's high buffering capacity.
####        Therefore, summer=Jan, Feb, Mar (01,02,03); winter=Jul, Aug, Sep (07,08,09).

indexS2011 <- datemap$dayn[datemap$year == "2011" & (datemap$month == "01" | datemap$month == "02" | datemap$month == "03")]
indexW2011 <- datemap$dayn[datemap$year == "2011" & (datemap$month == "07" | datemap$month == "08" | datemap$month == "09")]
indexS2018 <- datemap$dayn[datemap$year == "2018" & (datemap$month == "01" | datemap$month == "02" | datemap$month == "03")]
indexW2018 <- datemap$dayn[datemap$year == "2018" & (datemap$month == "07" | datemap$month == "08" | datemap$month == "09")]

meanS2011 <- mean(stack[[indexS2011]])
meanW2011 <- mean(stack[[indexW2011]])
meanS2018 <- mean(stack[[indexS2018]])
meanW2018 <- mean(stack[[indexW2018]])

trendS1811 <- meanS2018 - meanS2011
writeRaster(trendS1811, "~/Data/S18-S11.nc", format = "CDF")
trendW1811 <- meanW2018 - meanW2011
writeRaster(trendW1811, "~/Data/W18-W11.nc", format = "CDF")

### 3) Changes in max and min between 2018 - 2011

index2011 <- datemap$dayn[datemap$year == "2011"]
index2018 <- datemap$dayn[datemap$year == "2018"]

min2011 <- min(stack[[index2011]])
max2011 <- max(stack[[index2011]])
min2018 <- min(stack[[index2018]])
max2018 <- max(stack[[index2018]])

trendMax1811 <- max2018 - max2011
writeRaster(trendMax1811, "~/Data/max18-max11.nc", format = "CDF")
trendMin1811 <- min2018 - min2011
writeRaster(trendMin1811, "~/Data/min18-min11.nc", format = "CDF")

## II) FLUCTUATIONS
### 1) BIO2 = Mean Monthly Range (Mean of monthly (max temp - min temp))
datemap$yearmonth <- paste(datemap$year, datemap$month, sep = "-")
mr <- stack()
for(i in 2011:2018){
  year <- i
  for(j in 1:12){
    month <- j
    month <- formatC(month, width = 2, format = "d", flag = "0")
    index <- datemap$dayn[datemap$yearmonth == paste(year, month, sep="-")]
    aux <- max(stack[[index]]) - min(stack[[index]])
    mr <- addLayer(mr, aux)
  }
}
mmr <- mean(mr, na.rm = TRUE)
writeRaster(mmr, paste(src, "/Data/", "mmr.nc", sep = ""), format = "CDF", overwrite = TRUE)

### 2) BIO7 = Temperature Annual Range (BIO5-BIO6) -> mean annual range (mar)
ar <- stack()
for(i in 2011:2018){
  year <- i
  index <- datemap$dayn[datemap$year == year]
  aux <- max(stack[[index]]) - min(stack[[index]])
  ar <- addLayer(ar, aux)
}
mar <- mean(ar, na.rm = TRUE)
writeRaster(mar, paste(src, "/Data/", "mar.nc", sep = ""), format = "CDF", overwrite = TRUE)

### 3) BIO3 = Isothermality (BIO2/BIO7) (* 100)
isot <- (mmr/mar)*100
writeRaster(isot, paste(src, "/Data/isot.nc", sep=""), format = "CDF", overwrite = TRUE)

### 4) BIO4 = Temperature Seasonality (standard deviation *100)
### ** This is the mean of all years (2011-2018) of standard deviation of monthly means per year
### ** So, mean(sd(mean(months[1:12]))[1:8])

monthlymeans <- stack()
for(i in 2011:2018){
  year <- i
  for(j in 1:12){
    month <- j
    month <- formatC(month, width = 2, format = "d", flag = "0")
    yearmonth <- paste(year, month, sep = "-")
    index <- datemap$dayn[datemap$yearmonth == yearmonth]
    monthlymeans <- addLayer(monthlymeans, mean(stack[[index]], na.rm = TRUE))
  }
}
writeRaster(monthlymeans, paste(src, "/Data/monthlymeans.nc", sep=""), format = "CDF", overwrite = TRUE)

sds <- stack()
start <- 1
end <- 12
for(j in 2011:2018){
  sqdiff <- stack()
  mean <- mean(monthlymeans[[start:end]])
  for(i in start:end){
    sqdiff <- addLayer(sqdiff, (monthlymeans[[i]]-mean)^2)
  }
  sds <- addLayer(sds, sqrt(sum(sqdiff)/11))
  start <- start + 12
  end <- end + 12
  print(paste("year", j, "done"))
}
tseas <- mean(sds)
writeRaster(tseas, paste(src, "/Data/tseas.nc", sep = ""), format = "CDF", overwrite = TRUE)

## III) EXTREMES
### 1) BIO5 = Max Temperature of Warmest Month (MaxWM) -> mean of all years
monthlymeans <- stack(paste(src, "/Data/monthlymeans.nc", sep = ""))
meansvec <- vector()
for(i in 1:96){
  meansvec <- c(meansvec, mean(values(monthlymeans[[i]]), na.rm = TRUE))
}
warmestmonths <- data.frame(year = 2011:2018)
index <- vector()
months <- vector()
start <- 1
end <- 12
for(i in 1:8){
  index <- c(index, which(meansvec == max(meansvec[start:end])))
  months <- c(months, which(meansvec == max(meansvec[start:end]))- 12*(i-1))
  start <- start+12
  end <- end+12 
}
warmestmonths$index <- index
warmestmonths$months <- formatC(months, width = 2, format = "d", flag = "0")

maxwm <- stack()
for (year in 2011:2018){
  index <- datemap$dayn[datemap$yearmonth == paste(year, warmestmonths$months[warmestmonths$year == year], sep = "-")]
  maxwm <- addLayer(maxwm, max(stack[[index]]))
  print(paste("year", year, "done"))
}

mmaxwm <- mean(maxwm)
writeRaster(mmaxwm, paste(src, "/Data/mmaxwm.nc", sep = ""), format = "CDF", overwrite = TRUE)

### 2) BIO6 = Min Temperature of coldest Month (MinCM) -> mean of all years
monthlymeans <- stack(paste(src, "/Data/monthlymeans.nc", sep = ""))
meansvec <- vector()
for(i in 1:96){
  meansvec <- c(meansvec, mean(values(monthlymeans[[i]]), na.rm = TRUE))
}
coldestmonths <- data.frame(year = 2011:2018)
index <- vector()
months <- vector()
start <- 1
end <- 12
for(i in 1:8){
  index <- c(index, which(meansvec == min(meansvec[start:end])))
  months <- c(months, which(meansvec == min(meansvec[start:end]))- 12*(i-1))
  start <- start+12
  end <- end+12 
}
coldestmonths$index <- index
coldestmonths$months <- formatC(months, width = 2, format = "d", flag = "0")

mincm <- stack()
for (year in 2011:2018){
  index <- datemap$dayn[datemap$yearmonth == paste(year, coldestmonths$months[coldestmonths$year == year], sep = "-")]
  mincm <- addLayer(mincm, min(stack[[index]], na.rm = TRUE))
  print(paste("year", year, "done"))
}

mmincm <- mean(mincm)
writeRaster(mmincm, paste(src, "/Data/mmincm.nc", sep = ""), format = "CDF", overwrite = TRUE)

## 3) BIO10 = Mean Temperature of Warmest Quarter of all years (MWQ)
#### Based on previous data I'll define the warmest quarter as Jan, Feb, Mar (01,02,03)
mwq <- stack()
for(year in 2011:2018){
  index <- datemap$dayn[datemap$yearmonth == paste(year, "01", sep="-") | 
                          datemap$yearmonth == paste(year, "02", sep="-") |
                          datemap$yearmonth == paste(year, "03", sep="-")]
  mwq <- addLayer(mwq, mean(stack[[index]], na.rm = TRUE))
}
mmwq <- mean(mwq)
writeRaster(mmwq, paste(src, "/Data/mmwq.nc", sep = ""), format = "CDF", overwrite = TRUE)

## 4) BIO11 = Mean Temperature of Coldest Quarter of all year (MCQ)
#### Based on previous data I'll define the coldest quarter as Jul, Aug, Sep (07,08,09)
mcq <- stack()
for(year in 2011:2018){
  index <- datemap$dayn[datemap$yearmonth == paste(year, "07", sep="-") | 
                          datemap$yearmonth == paste(year, "08", sep="-") |
                          datemap$yearmonth == paste(year, "09", sep="-")]
  mcq <- addLayer(mcq, mean(stack[[index]], na.rm = TRUE))
}
mmcq <- mean(mcq)
writeRaster(mmcq, paste(src, "/Data/mmcq.nc", sep = ""), format = "CDF", overwrite = TRUE)

## 5) Number of days in a year with temperatures above (18) (DD18) average of 2011-2018
dd <- stack()
for(year in 2011:2018){
  index <- datemap$dayn[datemap$year == year]
  ddc <- addLayer(ddc, sum(stack[[index]]>18))
  print(year)
}
mdd <- mean(dd, na.rm = TRUE)
writeRaster(mdd, paste(src, "/Data/mddc.nc", sep = ""), format = "CDF", overwrite = TRUE)

## 6) Mean number of days per year with temperature below 15 (DD14)
dd14 <- stack()
for(year in 2011:2018){
  index <- datemap$dayn[datemap$year == year]
  dd15 <- addLayer(dd15, sum(stack[[index]]<14))
  print(year)
}
mdd14 <- mean(dd14, na.rm = TRUE)
writeRaster(mdd14, paste(src, "/Data/mdd14.nc", sep = ""), format = "CDF", overwrite = TRUE)

### IV) NOISE
## 1) Noise colour (B)
#In the cluster
detach("package:tidyr", unload = TRUE)
n <- 0
ext.betas <- function(timeseries){
  n <<- n+1
  timeseries <- timeseries[!is.na(timeseries)]
  if(length(timeseries) == 0){
    print(c(n, NA))
    return(NA)
  } else {
    spec <- spectrum(timeseries, plot = FALSE)
    x <- spec$freq
    y <- spec$spec
    b <- NA
    tryCatch({ 
      bfit <- nls(y ~ 1/x^b, start = list(b = 1), control = list(maxiter = 800))
      b <- summary(bfit)$coefficients[1]
    }, error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
    if(is.numeric(b)){ 
      print(c(n, b))
      return(b)
    } else {
      print(c(n, NA))
      return(NA)
    }
  }                   
}
index <- datemap$dayn[datemap$year != 2010 & datemap$year != 2019]
noise <- stack[[index]]
noisemap <- calc(noise, fun = ext.betas)
noisemap
writeRaster(noisemap, "/home/cristobg/tn20/noisemap.nc", format = "CDF", overwrite = TRUE)
#

#In local pc
file <- "~/Data/noisemap.nc"
noisemap <- stack(file)
noiseval <- values(noisemap) 
noiseval[noiseval > 1] <- NA  #a few values go up to 2 (probably errors, mess up plot)      
values(noisemap) <- noiseval
writeRaster(noisemap, "~/Data/noisemap.nc", format = "CDF", overwrite = TRUE)



# Extract SST variables for sampling sites
library(raster)
setwd("~/Data")

# TEMPERATURE VARIABLES
# TREND
# 1) gm: average of all period (2011-2018)
# FLUCTUATION
# 2) mmr: mean monthly range (BIO2)
# 3) mar: mean annual range (BIO7)
# 4) isot: isothermality (BIO3)
# 5) tseas: temperature seasonality
# EXTREMES
# 6) maxwm: max temperature of warmest month (BIO5)
# 7) mincm: min temperature of coldest month (BIO6)
# 8) mwq: mean temperature of warmest quarter (BIO10)
# 9) mcq: mean temperature of coldest quarter (BIo11)
# 10) mddc: degree days in a year above temperature (18)
# 11) dd14: degree days in a year below temperature (14)
# NOISE
# 12) noisemap: noise colour (B)

tempvar <- stack("gm.nc", "mmr.nc", "mar.nc", "isot.nc", "tseas.nc",
                 "mmaxwm.nc", "mmincm.nc", "mmwq.nc", "mmcq.nc", "mddc.nc",
                 "mdd14.nc", "noisemap.nc")
varnames <- c("gm", "mmr", "mar", "isot", "tseas", "maxwm", "mincm", "mwq", "mcq", "mddc", "dd14", "noisecol")
library(xlsx)
pops <- read.xlsx("~/Samplig Sites.xlsx", sheetIndex = 1, rowIndex = 1:31, colIndex = 4:6)
names(pops) <- c("pop", "lat", "long")

for(i in 1:12){
  pops$temp <- extract(tempvar[[i]], cbind(pops$long, pops$lat))
  # Areas too near the coast will likely have a NA value, even if they are under water
  # This code deals with this issue by looking ~1 km (one cell) around the initial point and avergaing the values it finds (modified from Piet's code)
  # 1 degree change in latitude equals ~111 km of linear distance
  # 1 degree change in longitiude varies a lot in term of linear distance, but should be ~85 km at (+-)40 degrees latitude
  nlat <- 1/111
  nlong <- 1/85
  while(sum(is.na(pops$temp)) > 0){ # This while loop checks that all the locations have data in them, if not, it looks one more cell around the intial cell until all have a value
    for(j in 1:length(pops$temp)){
      pops$temp[j] <- ifelse(is.na(pops$temp[j]),  #Test if data were unavailable when extracted above
                             mean(extract(tempvar[[i]], cbind(c(rep(pops$long[j]-nlong, 3), rep(pops$long[j], 3), rep(pops$long[j]+nlong, 3)),
                                                              rep(c(pops$lat[j]-nlat, pops$lat[j], pops$lat[j]+nlat), 3))), na.rm = T),  #If TRUE (data unavailable) it calculates the mean of the surrounding cells that have data
                             pops$temp[j])
    }
    nlat <- nlat + nlat
    nlong <- nlong + nlong
  }
  names(pops)[ncol(pops)] <- varnames[i]
}

for(i in 4:15){
  j <- i-3
  plot(pops[ , i], main = varnames[j])
}

file <- "~/temp_variables.csv"
write.csv(pops, file, row.names = FALSE)

